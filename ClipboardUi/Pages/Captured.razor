@page "/captured"
@implements IAsyncDisposable
@using System.IO
@using System.Linq
@using System.Net.WebSockets
@using System.Text
@using System.Text.Json

<PageTitle>Captured</PageTitle>

<h1>Captured Clipboard (Text)</h1>

@if (!string.IsNullOrEmpty(error))
{
    <div class="alert alert-danger">@error</div>
}
else if (captured is null)
{
    <p>Loading...</p>
}
else
{
    <div class="d-flex gap-2 align-items-center mb-3">
        <button class="btn btn-sm btn-primary" @onclick="ReloadAsync" disabled="@busy">Refresh</button>
        <span class="text-muted">@captured.Count items</span>
    </div>

    <ul class="nav nav-tabs mb-3">
        <li class="nav-item">
            <button class="nav-link @(activeTab == CapturedTab.Text ? "active" : "")"
                    type="button"
                    @onclick="@(() => activeTab = CapturedTab.Text)">
                Text
            </button>
        </li>
        <li class="nav-item">
            <button class="nav-link @(activeTab == CapturedTab.Images ? "active" : "")"
                    type="button"
                    @onclick="@(() => activeTab = CapturedTab.Images)">
                Images
            </button>
        </li>
    </ul>

    @if (selectedToSave is not null)
    {
        <div class="card mb-3">
            <div class="card-body">
                <h5 class="card-title">Save as Stored Text</h5>
                <div class="mb-2">
                    <label class="form-label">Name</label>
                    <input class="form-control" @bind="saveName" />
                </div>
                <div class="mb-2">
                    <label class="form-label">Hierarchy</label>
                    <select class="form-select" @bind="saveHierarchyId">
                        <option value="">(Root)</option>
                        @foreach (var h in hierarchies)
                        {
                            <option value="@h.Id">@h.Name</option>
                        }
                    </select>
                </div>
                <div class="mb-2">
                    <label class="form-label">Preview</label>
                    <div class="form-control" style="white-space: pre-wrap; max-height: 140px; overflow:auto;">
                        @selectedToSave.Content
                    </div>
                </div>
                <div class="d-flex gap-2">
                    <button class="btn btn-success" @onclick="SaveSelectedAsync" disabled="@busy">Save</button>
                    <button class="btn btn-outline-secondary" @onclick="CancelSave" disabled="@busy">Cancel</button>
                </div>
                @if (!string.IsNullOrEmpty(saveStatus))
                {
                    <div class="text-muted mt-2">@saveStatus</div>
                }
            </div>
        </div>
    }

    @if (activeTab == CapturedTab.Text)
    {
        <div class="list-group">
            @foreach (var item in captured)
            {
                <div class="list-group-item">
                    <div class="d-flex justify-content-between align-items-start gap-2">
                        <div class="flex-grow-1">
                        <div class="fw-bold d-flex align-items-center gap-2">
                            <span>@item.CreatedAt.ToLocalTime().ToString("g")</span>
                            <span class="badge text-bg-secondary">@FormatLanguage(item.Language)</span>
                        </div>
                            <div class="text-break" style="white-space: pre-wrap;">@Truncate(item.Content, 400)</div>
                        </div>
                        <div>
                            <button class="btn btn-sm btn-outline-primary" @onclick="() => BeginSave(item)" disabled="@busy">Save</button>
                        </div>
                    </div>
                </div>
            }
        </div>
    }
    else
    {
        @if (capturedImages is null)
        {
            <p>Loading images...</p>
        }
        else if (capturedImages.Count == 0)
        {
            <p class="text-muted">No images captured yet.</p>
        }
        else
        {
            <div class="d-flex flex-wrap gap-2">
                @foreach (var image in capturedImages)
                {
                    <div class="card" style="width: 220px;">
                        <img class="card-img-top" src="@BuildImageSrc(image)" alt="Clipboard image" />
                        <div class="card-body p-2">
                            <div class="text-muted small">@image.CreatedAt.ToLocalTime().ToString("g")</div>
                        </div>
                    </div>
                }
            </div>
        }
    }
}

@code {
    [Inject] private ClipboardApiClient Api { get; set; } = default!;

    private const int MaxItems = 100;
    private const int MaxImageItems = 20;
    private List<TextEntry>? captured;
    private List<ImageEntry>? capturedImages;
    private List<HierarchyEntry> hierarchies = [];
    private string? error;
    private bool busy;

    private TextEntry? selectedToSave;
    private string saveName = "";
    private int? saveHierarchyId;
    private string? saveStatus;
    private CapturedTab activeTab = CapturedTab.Text;

    private ClientWebSocket? _socket;
    private CancellationTokenSource? _wsCts;
    private Task? _wsTask;

    protected override async Task OnInitializedAsync()
    {
        await ReloadAsync();
        _wsTask = StartWebSocketAsync();
    }

    private async Task ReloadAsync()
    {
        busy = true;
        error = null;
        saveStatus = null;

        try
        {
            hierarchies = await Api.GetHierarchyAsync();
            captured = await Api.GetRecentTextAsync(MaxItems);
            capturedImages = await Api.GetRecentImagesAsync(MaxImageItems);
        }
        catch (Exception ex)
        {
            error = ex.Message;
        }
        finally
        {
            busy = false;
        }
    }

    private async Task StartWebSocketAsync()
    {
        _wsCts = new CancellationTokenSource();
        _socket = new ClientWebSocket();

        try
        {
            await _socket.ConnectAsync(BuildWebSocketUri(), _wsCts.Token);
            await ReceiveLoopAsync(_socket, _wsCts.Token);
        }
        catch (Exception ex)
        {
            error = $"WebSocket connection failed: {ex.Message}";
            await InvokeAsync(StateHasChanged);
        }
    }

    private Uri BuildWebSocketUri()
    {
        var baseUri = Api.BaseAddress;
        var scheme = baseUri.Scheme == "https" ? "wss" : "ws";
        var builder = new UriBuilder(baseUri)
        {
            Scheme = scheme,
            Path = "/ws/clipboard",
            Query = ""
        };
        return builder.Uri;
    }

    private async Task ReceiveLoopAsync(ClientWebSocket socket, CancellationToken cancellationToken)
    {
        var buffer = new byte[4096];

        while (!cancellationToken.IsCancellationRequested && socket.State == WebSocketState.Open)
        {
            using var stream = new MemoryStream();
            WebSocketReceiveResult result;

            do
            {
                result = await socket.ReceiveAsync(buffer, cancellationToken);
                if (result.MessageType == WebSocketMessageType.Close)
                {
                    return;
                }

                stream.Write(buffer, 0, result.Count);
            }
            while (!result.EndOfMessage);

            if (result.MessageType != WebSocketMessageType.Text)
            {
                continue;
            }

            var json = Encoding.UTF8.GetString(stream.ToArray());
            await HandleWebSocketMessageAsync(json);
        }
    }

    private async Task HandleWebSocketMessageAsync(string json)
    {
        WebSocketClipboardEvent? message;
        try
        {
            message = JsonSerializer.Deserialize<WebSocketClipboardEvent>(json,
                new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
        }
        catch
        {
            return;
        }

        if (message is null)
        {
            return;
        }

        if (message.Type == "text" && !string.IsNullOrWhiteSpace(message.Content))
        {
            captured ??= [];
            if (captured.Any(item => item.Id == message.Id))
            {
                return;
            }

            captured.Insert(0, new TextEntry(message.Id, message.Content, message.CreatedAt, FormatLanguage(message.Language)));
            if (captured.Count > MaxItems)
            {
                captured.RemoveRange(MaxItems, captured.Count - MaxItems);
            }

            await InvokeAsync(StateHasChanged);
            return;
        }

        if (message.Type == "image" && !string.IsNullOrWhiteSpace(message.Base64Data))
        {
            capturedImages ??= [];
            if (capturedImages.Any(item => item.Id == message.Id))
            {
                return;
            }

            capturedImages.Insert(0, new ImageEntry(message.Id, message.CreatedAt, message.Base64Data));
            if (capturedImages.Count > MaxImageItems)
            {
                capturedImages.RemoveRange(MaxImageItems, capturedImages.Count - MaxImageItems);
            }

            await InvokeAsync(StateHasChanged);
        }
    }

    private void BeginSave(TextEntry item)
    {
        selectedToSave = item;
        saveHierarchyId = null;
        saveName = BuildDefaultName(item.Content);
        saveStatus = null;
    }

    private void CancelSave()
    {
        selectedToSave = null;
        saveStatus = null;
    }

    private async Task SaveSelectedAsync()
    {
        if (selectedToSave is null)
        {
            return;
        }

        busy = true;
        saveStatus = null;
        try
        {
            var created = await Api.CreateStoredFromClipboardAsync(
                new CreateStoredFromClipboardRequest(selectedToSave.Id, saveName, saveHierarchyId));

            saveStatus = $"Saved as StoredTextEntries Id {created.Id}.";
            selectedToSave = null;
        }
        catch (Exception ex)
        {
            saveStatus = $"Save failed: {ex.Message}";
        }
        finally
        {
            busy = false;
        }
    }

    private static string BuildDefaultName(string content)
    {
        var singleLine = content.ReplaceLineEndings(" ").Trim();
        if (string.IsNullOrWhiteSpace(singleLine))
        {
            return "Untitled";
        }
        return singleLine.Length > 60 ? singleLine[..60] : singleLine;
    }

    private static string Truncate(string content, int max)
    {
        if (content.Length <= max)
        {
            return content;
        }
        return content[..max] + ".";
    }

    private static string BuildImageSrc(ImageEntry image) => $"data:image/png;base64,{image.Base64Data}";
    private static string FormatLanguage(string? language) =>
        string.IsNullOrWhiteSpace(language) ? "Text" : language;

    public async ValueTask DisposeAsync()
    {
        if (_wsCts is not null)
        {
            _wsCts.Cancel();
        }

        if (_socket is not null)
        {
            try
            {
                if (_socket.State == WebSocketState.Open)
                {
                    await _socket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Closing", CancellationToken.None);
                }
            }
            catch
            {
                // ignore shutdown errors
            }

            _socket.Dispose();
        }

        _wsCts?.Dispose();
    }

    private sealed record WebSocketClipboardEvent(string Type, int Id, string? Content, string? Base64Data, DateTimeOffset CreatedAt, string? Language);
    private enum CapturedTab
    {
        Text,
        Images
    }
}
